<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>vue学习</title>
  <script src="https://cdn.bootcss.com/vue/2.5.17-beta.0/vue.min.js"></script>
</head>

<body>
  <div id="app">
    <h2>计算属性缓存 vs 方法</h2>
    <p> Original messagee:{{message}}</p>
    <p> Function Reversed messagee:{{reverseMessage()}}</p>
    <p> Computed Reversed messagee:{{reverseMessage}}</p>
    <h2>计算属性 vs 侦听属性</h2>
    <div id="id">
      {{fullName}}
    </div>
    <h2>计算属性的 setter</h2>
    <div id="id1">
      {{fullName}}
    </div>
  </div>
</body>
<script>
  /*
  #计算属性缓存 vs 方法
  计算属性是基于它们的依赖进行缓存的,如果message没有改变,计算属性会直接返回结果.只在相关依赖发生改变时它们才会重新求值
  方法:每当触发重新渲染的时候,滴啊用的方法总会执行
  #计算属性 vs 侦听属性
   */
  var app = new Vue({
    el: '#app',
    data: {
      message: 'Hello',
      firstName: 'Foo',
      lastName: 'Bar',
      fullName: 'Foo Bar'
    },
    computed: {
      // getter
      // 计算属性的getter
      reverseMessage: function () {
        // this指向app实例
        return this.message.split('').reverse().join('')
      },
      // fullName: function () {
      //   // 更好
      //   return this.firstName + ' ' + this.lastName
      // },
      // setter
      fullName: {
        get: function () {
          return this.firstName + ' ' + this.lastName
        },
        set: function (newValue) {
          var names = newValue.split(' ')
          this.firstName = names[0]
          this.lastName = names[name.length - 1]
        }
      }
    },
    methods: {
      reverseMessage: function () {
        return this.message.split('').reverse().join('')
      }
    },
    watch: {
      firstName: function (val) {
        this.FullName = val + ' ' + this.lastName
      },
      lastName: function (val) {
        this.FullName = this.firstName + ' ' + val
      }
    }
  })
</script>

</html>
